let ball = {
        xPos: "1", //adresses to store in
        yPos: "10",
        xVel: "11",
        yVel: "100",
    }
    let temp = "101"
    let temp2 = "110"
    let paddle = {
        leftPaddle: "111",
        rightPaddle: "1000"
    }

    //INIT
    loadImmidiate(paddle.rightPaddle, 1110000000) //loads r paddle into game
    loadImmidiate(paddle.leftPaddle, 1110000000)  //loads l paddle into game
    loadImmidiate(ball.xPos, display[7]) //sets the balls starting pos
    loadImmidiate(ball.yPos, 100000000) //creates the ball
    loadImmidiate(ball.xVel, 1) //makes the ball move so it doesnt just spawn in and stay there forever
    loadImmidiate(ball.yVel, 0) //resets y velocity so it isnt messed up from previous data held in the register its located in
    jump(1010011) //whereever the main loop is
    
    loadImmidiate(temp, 11)
    copy(temp, sevenSeg)
    refresh7Seg()

    label("gameOver") //trigger when gave loose
    loadImmidiate(temp, 111111111111111)
    copy(temp, sevenSeg)
    refresh7Seg()
    halt()

    label("returnFromBranch") //a hacky way to get conditional branch returns with only one extra clock cycle
    returnFromBranch()


    //is paddle at screen border
    label("moveRPaddleDown")
    sub(paddle.rightPaddle, 111, temp2) //if right paddle is at bottom of screen
    jumpIfZero(labels.returnFromBranch, temp2) //break
    rShift(paddle.rightPaddle, paddle.rightPaddle) //otherwise move paddle down
    returnFromBranch()

    label("moveLPaddleDown")
    sub(paddle.leftPaddle, 111, temp2) //if l paddle is at bottom of screen
    jumpIfZero(labels.returnFromBranch, temp2) //break
    rShift(paddle.leftPaddle, paddle.leftPaddle) //otherwise move paddle down
    returnFromBranch()

    label("moveRPaddleUp")
    sub(paddle.rightPaddle, 1110000000000000, temp2) //if r paddle is at top of screen
    jumpIfZero(labels.returnFromBranch, temp2) //break
    lShift(paddle.rightPaddle, paddle.rightPaddle) //otherwise move paddle up
    returnFromBranch()

    label("moveLPaddleUp")
    sub(paddle.leftPaddle, 1110000000000000, temp2)
    jumpIfZero(labels.returnFromBranch, temp2)
    lShift(paddle.leftPaddle, paddle.leftPaddle)
    returnFromBranch()




    //paddle moving
    label("updatePaddle")

    getInput(temp) //save user input into temp
    and(temp, 1, temp2) //if they want to move the paddles, use bitwise logic to determen which ones the players want to move
    branchIfPositive(labels.moveRPaddleDown, temp2)
    and(temp, 10, temp2)
    branchIfPositive(labels.moveLPaddleDown, temp2)
    and(temp, 100, temp2)
    branchIfPositive(labels.moveRPaddleUp, temp2)
    and(temp, 1000, temp2)
    branchIfPositive(labels.moveLPaddleUp, temp2)
    returnFromBranch()

    //moving ball
    label("moveBallUp")
    lShift(ball.yPos, ball.yPos)
    returnFromBranch()

    label("moveBallDown")
    rShift(ball.yPos, ball.yPos)
    returnFromBranch()

    label("moveBallRight")
    sub(ball.xPos, 1, ball.xPos)
    returnFromBranch()

    label("moveBallLeft")
    add(ball.xPos, 1, ball.xPos)
    returnFromBranch()

    //check ball velocity and move it accordingly
    label("moveBall")
    branchIfNegative(labels.moveBallDown, ball.yVel)
    branchIfPositive(labels.moveBallUp, ball.yVel)
    branchIfNegative(labels.moveBallRight, ball.xVel)
    branchIfPositive(labels.moveBallLeft, ball.xVel)
    returnFromBranch()

    //paddle collision checks
    label("rightPaddleCollisionCheck")
    and(ball.yPos, paddle.rightPaddle, temp)
    jumpIfZero(labels.returnFromBranch, temp) //if the ball and the right paddle arnt at the same height, break
    loadImmidiate(ball.xVel, 1) //otherwise make the ball move left
    returnFromBranch()

    label("leftPaddleCollisionCheck")
    and(ball.yPos, paddle.leftPaddle, temp)
    jumpIfZero(labels.returnFromBranch, temp) //if the ball and right paddle arnt at the same height, break
    loadImmidiate(ball.xVel, 1000000000000000) //otherwise set the ball velocity to move right
    returnFromBranch()


    //change vertical velocity of ball
    label("bounceUp")
    loadImmidiate(ball.yVel, 1)
    returnFromBranch()

    label("bounceDown")
    loadImmidiate(ball.yVel, 1000000000000000)
    returnFromBranch()

    //ball collision checks for the floor, cieling and game over checks if the ball missed the paddle
    label("nonPaddleCollisionCheck")
    branchIfNegative(labels.bounceDown, ball.yPos) //if ball at top of screen it down
    sub(ball.yPos, 1, temp) //check if ball is it bottom of screen
    branchIfZero(labels.bounceUp, temp) //if so bounce it down
    sub(ball.xPos, 11111111, temp) //if ball is at the end of the screen
    jumpIfZero(labels.gameOver, temp) //game over
    sub(ball.xPos, 1111001, temp) //if ball is at other end of the screen
    jumpIfZero(labels.gameOver, temp) //also game over
    returnFromBranch()



    //rendering
    label("render")
    copy(paddle.rightPaddle, display[0])
    copy(paddle.leftPaddle, display[14])
    loadWritePointer(ball.xPos)
    copy(ball.yPos, "pointer")
    loadImmidiate(temp, ball.yPos) //TEMP TESTING CODE
    copy(temp, sevenSeg)
    refresh7Seg() //END OF TEMP TEST CODE
    refreshDisplay()
    returnFromBranch()

    //main loop
    label("mainLoop")
    console.log(assembledInstrucions.length)
    branch(labels.updatePaddle) //update the paddle pos
    branch(labels.nonPaddleCollisionCheck) //check if the ball is at the top or bottom, or out

    sub(ball.xPos, 11111110, temp) //if the ball is at the second to most left pixel
    branchIfZero(labels.leftPaddleCollisionCheck, temp) //if so check if it collides with the left paddel
    sub(ball.xPos, 11110001, temp) //if the ball is at the second to most right pixel
    branchIfZero(labels.rightPaddleCollisionCheck, temp) //if so check if it collides with the right paddel
    branch(labels.moveBall)
    branch(labels.render) //render everything
    jump(labels.mainLoop) //do the loop again, so you can actually play the game